/**
 * Migration Reporter
 * Generates comprehensive migration reports and documentation
 */

import { Logger } from '../utils/logger';
import { StackAnalysisResult } from './cloudformation-analyzer';
import { ResourceMappingResult } from './resource-mapper';
import { ValidationResult } from './migration-validator';
import { MigrationOptions } from './migration-engine';
import * as fs from 'fs';
import * as path from 'path';

/**
 * Generates detailed migration reports and documentation
 */
export class MigrationReporter {
  constructor(private logger: Logger) {}

  async generateReport(
    outputDir: string,
    analysisResult: StackAnalysisResult,
    mappingResult: ResourceMappingResult,
    validationResult: ValidationResult,
    options: MigrationOptions
  ): Promise<string> {
    const reportPath = path.join(outputDir, 'MIGRATION_REPORT.md');
    
    const reportContent = this.buildReport(
      analysisResult,
      mappingResult,
      validationResult,
      options
    );

    fs.writeFileSync(reportPath, reportContent);
    
    this.logger.info(`Migration report generated: ${reportPath}`);
    
    return reportPath;
  }

  private buildReport(
    analysisResult: StackAnalysisResult,
    mappingResult: ResourceMappingResult,
    validationResult: ValidationResult,
    options: MigrationOptions
  ): string {
    const timestamp = new Date().toISOString();
    
    return `# Migration Report

**Generated:** ${timestamp}  
**Tool Version:** Platform Migration Tool v1.0.0  
**Source Stack:** ${options.stackName}  
**Target Service:** ${options.serviceName}  
**Compliance Framework:** ${options.complianceFramework || 'commercial'}

## Executive Summary

${this.generateExecutiveSummary(analysisResult, mappingResult, validationResult)}

## Migration Results

### ✅ Successfully Migrated Components

${this.generateSuccessfulComponentsList(mappingResult)}

### ⚠️ Action Required: Manually Migrate Unmappable Resources

${this.generateUnmappableResourcesList(mappingResult)}

## Detailed Analysis

### Original Stack Inventory

${this.generateOriginalInventory(analysisResult)}

### Resource Mapping Results

${this.generateMappingResults(mappingResult)}

### Template Validation

${this.generateValidationResults(validationResult)}

## Generated Files

The following files have been created in your migrated project:

- \`service.yml\` - Platform service manifest
- \`logical-id-map.json\` - Logical ID preservation mapping
- \`patches.ts\` - Template for unmappable resources
- \`src/\` - Copied source code (if available)
- \`.gitignore\` - Basic Git ignore rules
- \`MIGRATION_REPORT.md\` - This report

## Next Steps

${this.generateNextSteps(mappingResult, validationResult)}

## Technical Details

### Logical ID Preservation

${this.generateLogicalIdDetails(validationResult)}

### Migration Validation

${this.generateValidationDetails(validationResult)}

---

*This report was automatically generated by the Platform Migration Tool. For questions or issues, please refer to the platform documentation or contact the platform team.*
`;
  }

  private generateExecutiveSummary(
    analysisResult: StackAnalysisResult,
    mappingResult: ResourceMappingResult,
    validationResult: ValidationResult
  ): string {
    const totalResources = analysisResult.resources.length;
    const mappedResources = mappingResult.mappedResources.length;
    const unmappableResources = mappingResult.unmappableResources.length;
    const mappingSuccessRate = Math.round((mappedResources / totalResources) * 100);

    const diffStatus = validationResult.diffResult === 'NO CHANGES' 
      ? '**✅ ZERO CHANGES** - Safe to deploy' 
      : '**⚠️ HAS CHANGES** - Manual review required';

    return `**Migration Status:** ${validationResult.success ? 'COMPLETED' : 'COMPLETED WITH WARNINGS'}  
**Final Diff Result:** ${diffStatus}  
**Mapping Success Rate:** ${mappingSuccessRate}% (${mappedResources}/${totalResources} resources)  
**Components Created:** ${mappingResult.components.length}  
**Manual Action Required:** ${unmappableResources} resources

${validationResult.diffResult === 'NO CHANGES' 
  ? 'Your migration is complete and safe to deploy. The synthesized CloudFormation template is identical to your original stack, ensuring no resource state changes.'
  : 'Your migration requires manual review. Some differences were detected between the original and migrated templates. Please review the validation details below.'}`;
  }

  private generateSuccessfulComponentsList(mappingResult: ResourceMappingResult): string {
    if (mappingResult.components.length === 0) {
      return 'No components were successfully migrated.';
    }

    let content = 'The following components were successfully created:\n\n';
    
    mappingResult.components.forEach(component => {
      const relatedResources = mappingResult.mappedResources
        .filter(r => r.componentName === component.name)
        .map(r => r.logicalId);

      content += `#### ${component.name} (${component.type})\n\n`;
      content += '**Configuration:**\n```yaml\n';
      content += `name: ${component.name}\n`;
      content += `type: ${component.type}\n`;
      content += `config:\n`;
      
      Object.entries(component.config).forEach(([key, value]) => {
        content += `  ${key}: ${JSON.stringify(value)}\n`;
      });
      
      if (component.binds && component.binds.length > 0) {
        content += `binds:\n`;
        component.binds.forEach(bind => {
          content += `  - to: ${bind.to}\n`;
          content += `    capability: ${bind.capability}\n`;
          content += `    access: ${bind.access}\n`;
        });
      }
      
      content += '```\n\n';
      content += `**Mapped Resources:** ${relatedResources.join(', ')}\n\n`;
    });

    return content;
  }

  private generateUnmappableResourcesList(mappingResult: ResourceMappingResult): string {
    if (mappingResult.unmappableResources.length === 0) {
      return '🎉 **All resources were successfully migrated!** No manual action required.';
    }

    let content = `${mappingResult.unmappableResources.length} resources could not be automatically migrated and require manual intervention:\n\n`;
    
    mappingResult.unmappableResources.forEach((resource, index) => {
      content += `#### ${index + 1}. ${resource.logicalId} (${resource.type})\n\n`;
      content += `**Reason:** ${resource.reason}\n\n`;
      content += `**Suggested Action:** ${resource.suggestedAction}\n\n`;
      content += '**Original CloudFormation Definition:**\n```json\n';
      content += JSON.stringify(resource.cfnDefinition, null, 2);
      content += '\n```\n\n';
      content += '**How to migrate this resource:**\n';
      content += '1. Review the original CloudFormation definition above\n';
      content += '2. Add equivalent code to `patches.ts` using L1 constructs\n';
      content += '3. Run `svc plan` to verify the resource is included\n';
      content += '4. Run `cdk diff` to ensure no unintended changes\n\n';
      content += '---\n\n';
    });

    return content;
  }

  private generateOriginalInventory(analysisResult: StackAnalysisResult): string {
    const resourcesByType = new Map<string, number>();
    
    analysisResult.resources.forEach(resource => {
      const count = resourcesByType.get(resource.type) || 0;
      resourcesByType.set(resource.type, count + 1);
    });

    let content = `**Total Resources:** ${analysisResult.resources.length}\n\n`;
    content += '**Resource Types:**\n\n';
    
    Array.from(resourcesByType.entries())
      .sort((a, b) => b[1] - a[1])  // Sort by count descending
      .forEach(([type, count]) => {
        content += `- ${type}: ${count}\n`;
      });

    return content;
  }

  private generateMappingResults(mappingResult: ResourceMappingResult): string {
    const totalResources = mappingResult.mappedResources.length + mappingResult.unmappableResources.length;
    const successRate = Math.round((mappingResult.mappedResources.length / totalResources) * 100);

    let content = `**Mapping Success Rate:** ${successRate}%\n\n`;
    
    content += '**Component Types Created:**\n\n';
    const componentTypes = new Map<string, number>();
    mappingResult.components.forEach(component => {
      const count = componentTypes.get(component.type) || 0;
      componentTypes.set(component.type, count + 1);
    });

    Array.from(componentTypes.entries()).forEach(([type, count]) => {
      content += `- ${type}: ${count} component${count > 1 ? 's' : ''}\n`;
    });

    if (mappingResult.bindings.length > 0) {
      content += `\n**Inter-component Bindings:** ${mappingResult.bindings.length} detected\n`;
    }

    return content;
  }

  private generateValidationResults(validationResult: ValidationResult): string {
    let content = `**Validation Status:** ${validationResult.success ? 'PASSED' : 'FAILED'}\n`;
    content += `**Template Diff Status:** ${validationResult.diffResult}\n\n`;

    const tc = validationResult.templateComparison;
    content += '**Template Comparison:**\n\n';
    content += `| Metric | Count |\n`;
    content += `|--------|-------|\n`;
    content += `| Original Resources | ${tc.originalResourceCount} |\n`;
    content += `| Migrated Resources | ${tc.migratedResourceCount} |\n`;
    content += `| Matching Resources | ${tc.matchingResources} |\n`;
    content += `| Missing Resources | ${tc.missingResources.length} |\n`;
    content += `| Extra Resources | ${tc.extraResources.length} |\n`;
    content += `| Modified Resources | ${tc.modifiedResources.length} |\n`;

    return content;
  }

  private generateNextSteps(
    mappingResult: ResourceMappingResult,
    validationResult: ValidationResult
  ): string {
    const steps: string[] = [];

    if (mappingResult.unmappableResources.length > 0) {
      steps.push('1. **Review Unmappable Resources** - Add the unmappable resources to `patches.ts` following the examples provided above');
      steps.push('2. **Test Patches** - Run `svc plan` to verify your patches are working correctly');
    }

    if (validationResult.diffResult === 'HAS CHANGES') {
      steps.push(`${steps.length + 1}. **Review Template Differences** - Carefully review the validation details to understand what changed`);
      steps.push(`${steps.length + 1}. **Verify State Preservation** - Ensure that stateful resources (databases, S3 buckets) maintain their logical IDs`);
    }

    steps.push(`${steps.length + 1}. **Update Service Metadata** - Modify the \`owner\` field in \`service.yml\` to reflect your team`);
    steps.push(`${steps.length + 1}. **Test Locally** - Run \`svc local up\` to test your service locally`);
    steps.push(`${steps.length + 1}. **Deploy** - When ready, deploy using \`svc deploy\``);

    if (validationResult.diffResult === 'NO CHANGES') {
      steps.push(`${steps.length + 1}. **🎉 Celebrate** - Your migration achieved zero CloudFormation changes!`);
    }

    return steps.join('\n');
  }

  private generateLogicalIdDetails(validationResult: ValidationResult): string {
    return `The migration tool generated a \`logical-id-map.json\` file to preserve CloudFormation resource state. This ensures that your existing resources (especially stateful ones like databases) are not replaced during the migration.

**How it works:**
1. The platform's resolver engine detects the presence of \`logical-id-map.json\`
2. It applies a CDK Aspect that overrides the logical IDs of synthesized resources
3. Resources maintain their original CloudFormation logical IDs
4. No resource replacement occurs when you deploy the migrated service

**Validation:** ${validationResult.diffResult === 'NO CHANGES' ? 'Logical ID preservation is working correctly' : 'Review template differences to ensure preservation is working'}`;
  }

  private generateValidationDetails(validationResult: ValidationResult): string {
    let content = '**Platform Validation:**\n';
    
    if (validationResult.success) {
      content += '✅ Service manifest is valid and can be deployed\n';
    } else {
      content += '❌ Service manifest has validation errors:\n';
      validationResult.validationErrors.forEach(error => {
        content += `  - ${error}\n`;
      });
    }

    if (validationResult.warnings.length > 0) {
      content += '\n**Warnings:**\n';
      validationResult.warnings.forEach(warning => {
        content += `  - ${warning}\n`;
      });
    }

    content += '\n**Template Diff Output:**\n```\n';
    content += validationResult.diffOutput || 'No differences detected';
    content += '\n```\n';

    return content;
  }
}