#!/usr/bin/env node
/* Shinobi one-shot bootstrap + migration (Cursor-ready)
 * - Writes a Projen blueprint (.projenrc.ts) for pnpm+Turbo+Changesets
 * - Runs projen + pnpm install
 * - Migrates legacy packages into packages/** (package-per-component)
 * - Scopes package names to @shinobi/*
 * - Updates tsconfig paths
 * - Rewrites import specifiers to @shinobi/*
 * - Emits ./.shinobi/MIGRATION_REPORT.md
 *
 * Safe-by-default:
 * - Requires clean git tree unless --force
 * - Uses `git mv` when possible to preserve history
 */

import { spawnSync } from 'node:child_process';
import { promises as fsp } from 'node:fs';
import fs from 'node:fs';
import path from 'node:path';

const SCOPE = '@shinobi';
const repo = process.cwd();
const args = new Set(process.argv.slice(2));
const FORCE = args.has('--force') || args.has('-f');

const log = (...a) => console.log('[shinobi]', ...a);
const warn = (...a) => console.warn('[shinobi:warn]', ...a);
const fail = (m) => { console.error('[shinobi:ERR]', m); process.exit(1); };

function run(cmd, argv = [], opts = {}) {
  const res = spawnSync(cmd, argv, { stdio: 'inherit', shell: process.platform === 'win32', ...opts });
  if (res.status !== 0) fail(`Command failed: ${cmd} ${argv.join(' ')}`);
}

function runSilent(cmd, argv = [], opts = {}) {
  const res = spawnSync(cmd, argv, { stdio: 'pipe', shell: process.platform === 'win32', ...opts });
  return { code: res.status ?? 0, out: (res.stdout || Buffer.alloc(0)).toString('utf8'), err: (res.stderr || Buffer.alloc(0)).toString('utf8') };
}

async function ensureDir(d) { await fsp.mkdir(d, { recursive: true }); }
async function writeFile(file, content) { await ensureDir(path.dirname(file)); await fsp.writeFile(file, content, 'utf8'); }
async function readJson(file) { try { return JSON.parse(await fsp.readFile(file, 'utf8')); } catch { return undefined; } }
async function writeJson(file, obj) { await ensureDir(path.dirname(file)); await fsp.writeFile(file, JSON.stringify(obj, null, 2) + '\n', 'utf8'); }
function exists(p) { try { fs.accessSync(p); return true; } catch { return false; } }

function assertCleanGit() {
  const { code, out } = runSilent('git', ['status', '--porcelain']);
  if (code !== 0) fail('git not available or not a git repo.');
  if (!FORCE && out.trim().length) fail('Working tree not clean. Commit/stash or re-run with --force.');
}

async function stepProjenBlueprint() {
  const projenFile = path.join(repo, '.projenrc.ts');
  const backup = exists(projenFile) ? `.projenrc.ts.bak.${Date.now()}` : null;
  if (backup) {
    await fsp.copyFile(projenFile, path.join(repo, backup));
    warn(`Backed up existing .projenrc.ts -> ${backup}`);
  }

  const projenTs = `
// GENERATED by shinobi-one-shot.mjs — single source of truth
import { javascript, typescript, JsonFile, YamlFile, TextFile } from 'projen';

const root = new javascript.NodeProject({
  name: 'shinobi-platform',
  defaultReleaseBranch: 'main',
  packageManager: javascript.NodePackageManager.PNPM,
  projenrcTs: true,
  licensed: false,
  jest: false,           // Vitest in packages
  eslint: true,
  prettier: true,
  minNodeVersion: '20.10.0',
  devDeps: [
    'projen',
    'typescript',
    'vitest',
    'tsx',
    '@types/node',
    '@changesets/cli',
    'ts-morph',          // for import rewrites in migration
  ],
});

root.package.addField('private', true);
root.package.addField('workspaces', ['packages/*', 'plugins/*', 'tools/*', 'apps/*']);

new YamlFile(root, 'pnpm-workspace.yaml', { obj: { packages: ['packages/*', 'plugins/*', 'tools/*', 'apps/*'] } });

new JsonFile(root, 'turbo.json', {
  obj: {
    $schema: 'https://turbo.build/schema.json',
    pipeline: {
      lint: { outputs: [] },
      typecheck: { outputs: [] },
      build: { dependsOn: ['^build'], outputs: ['dist/**'] },
      test: { dependsOn: ['build'], outputs: ['coverage/**'] },
    },
  },
});

new JsonFile(root, 'tsconfig.base.json', {
  obj: {
    compilerOptions: {
      target: 'ES2022',
      module: 'ESNext',
      moduleResolution: 'Bundler',
      lib: ['ES2022', 'DOM'],
      strict: true,
      resolveJsonModule: true,
      noUncheckedIndexedAccess: true,
      skipLibCheck: true,
      baseUrl: '.',
      paths: { '${SCOPE}/*': ['packages/*/src'] },
      types: ['node'],
    },
  },
});

// Changesets baseline
new JsonFile(root, '.changeset/config.json', {
  obj: {
    $schema: 'https://unpkg.com/@changesets/config@2.3.1/schema.json',
    changelog: ['@changesets/changelog-github', { repo: '${'{'}{github.repository}{'}'}' }],
    commit: false,
    fixed: [],
    linked: [],
    access: 'public',
    baseBranch: 'main',
    updateInternalDependencies: 'patch',
    ignore: [],
  },
});
new TextFile(root, '.changeset/README.md', { lines: ['# Changesets', '', 'Add a changeset for any change to /packages or /apps.'] });

// PR template + CODEOWNERS (adjust teams later)
new TextFile(root, '.github/PULL_REQUEST_TEMPLATE.md', {
  lines: [
    '## What', '', '## Why', '', '## How', '', '## Tests & Evidence', '', '## Risk & Rollback', '', '## Breaking Changes', '', '## Changesets', '- [ ] Added for packages/apps',
  ],
});
new TextFile(root, '.github/CODEOWNERS', {
  lines: [
    '* @org/platform-core',
    '/packages/contracts/ @org/contracts-owners',
    '/packages/core-engine/ @org/core-engine-owners',
    '/packages/components/** @org/components-owners',
    '/apps/** @org/app-owners',
  ],
});

// Root tasks
root.addTask('bootstrap', { exec: 'pnpm install && npx projen' });
root.addTask('lint', { exec: 'pnpm -r lint' });
root.addTask('typecheck', { exec: 'pnpm -r typecheck' });
root.addTask('build', { exec: 'pnpm dlx turbo run build' });
root.addTask('test', { exec: 'pnpm dlx turbo run test -- --run' });
root.addTask('synth:check', { exec: 'npx projen && git diff --quiet || (git status --porcelain; echo "Run npx projen and commit."; exit 1)' });

// seed a few packages so the workspace is valid; you can add more later
const vitestDefaults = {
  sampleCode: false, jest: false, eslint: true,
  tsconfig: { compilerOptions: { rootDir: 'src', outDir: 'dist', declaration: true } },
  devDeps: ['vitest', 'tsx', 'typescript', '@types/node'],
  release: false,
};

function addTsLib(name, outdir, options = {}) {
  const p = new typescript.TypeScriptProject({
    parent: root, outdir, name, defaultReleaseBranch: 'main', prettier: true, ...vitestDefaults, ...options,
  });
  new TextFile(p, 'src/index.ts', { lines: ['export const ok = true;'] });
  new TextFile(p, 'vitest.config.ts', { lines: ['import { defineConfig } from "vitest/config";', 'export default defineConfig({ test: { reporters: "default" } });'] });
  return p;
}

addTsLib('${SCOPE}/core-foundation', 'packages/core-foundation', { deps: ['aws-cdk-lib', 'constructs'] });
addTsLib('${SCOPE}/standards-logging', 'packages/standards-logging', { deps: ['pino'] });
addTsLib('${SCOPE}/standards-config', 'packages/standards-config', { deps: ['zod'] });
addTsLib('${SCOPE}/cli-shinobi', 'packages/cli-shinobi', { deps: ['commander'] });

root.synth();
`.trim() + '\n';

  await writeFile(projenFile, projenTs);
  log('Wrote .projenrc.ts');
}

function ensurePnpm() {
  let ok = runSilent('pnpm', ['-v']).code === 0;
  if (!ok) {
    log('pnpm not found, attempting to activate via corepack…');
    run('corepack', ['enable']);
    run('corepack', ['prepare', 'pnpm@9.0.0', '--activate']);
    ok = runSilent('pnpm', ['-v']).code === 0;
    if (!ok) {
      warn('corepack failed; falling back to npm i -g pnpm');
      run('npm', ['i', '-g', 'pnpm@9']);
    }
  }
}

async function stepProjenSynthAndInstall() {
  log('Synthesizing Projen files…');
  run('npx', ['-y', 'projen']);
  ensurePnpm();
  log('Installing workspace deps…');
  run('pnpm', ['install']);
  // synth again after deps to normalize
  run('npx', ['-y', 'projen']);
}

async function listPackageJsonGlobs() {
  const candidates = new Set();
  function maybePush(rel) {
    const full = path.join(repo, rel);
    if (exists(full) && rel !== 'package.json') candidates.add(rel);
  }
  // legacy spots
  for (const base of ['components', 'libs']) {
    if (exists(path.join(repo, base))) {
      for (const ent of fs.readdirSync(path.join(repo, base), { withFileTypes: true })) {
        if (ent.isDirectory()) maybePush(path.join(base, ent.name, 'package.json'));
      }
    }
  }
  // packages/*
  if (exists(path.join(repo, 'packages'))) {
    for (const ent of fs.readdirSync(path.join(repo, 'packages'), { withFileTypes: true })) {
      if (ent.isDirectory()) maybePush(path.join('packages', ent.name, 'package.json'));
    }
  }
  // one-level leaf dirs
  for (const ent of fs.readdirSync(repo, { withFileTypes: true })) {
    if (ent.isDirectory() && !['node_modules', '.git', 'packages', 'plugins', 'tools', 'apps'].includes(ent.name)) {
      maybePush(path.join(ent.name, 'package.json'));
    }
  }
  return Array.from(candidates);
}

function basenameNoScope(n) {
  if (!n) return n;
  if (n.startsWith('@')) return n.split('/')[1];
  return n;
}

function targetDirFor(relDir) {
  if (relDir.startsWith('components/')) return path.posix.join('packages/components', path.posix.basename(relDir));
  if (relDir.startsWith('libs/')) return path.posix.join('packages', path.posix.basename(relDir));
  if (relDir.startsWith('packages/')) return relDir;
  return path.posix.join('packages', path.posix.basename(relDir));
}

async function stepMigrateLayoutAndPaths() {
  log('Discovering legacy packages…');
  const pkgJsons = await listPackageJsonGlobs();
  const pkgs = [];
  for (const rel of pkgJsons) {
    const dir = path.posix.dirname(rel);
    const pkg = await readJson(path.join(repo, rel));
    if (!pkg) continue;
    pkgs.push({ dir, name: pkg.name ?? path.posix.basename(dir), private: !!pkg.private });
  }

  const moves = [];
  for (const p of pkgs) {
    const to = targetDirFor(p.dir);
    if (to !== p.dir) moves.push({ from: p.dir, to, reason: 'align-to-packages-shape' });
  }
  const moveMap = Object.fromEntries(moves.map(m => [m.from, m.to]));
  const movedNames = new Set(pkgs.map(p => path.posix.basename(targetDirFor(p.dir))));

  await ensureDir(path.join(repo, '.shinobi'));
  const report = [];
  report.push('# MIGRATION REPORT');
  report.push('');
  report.push('## Proposed Moves');
  for (const m of moves) report.push(`- ${m.from} -> ${m.to} (${m.reason})`);
  if (!moves.length) report.push('- (no directory moves needed)');

  // Apply moves
  for (const m of moves) {
    const src = path.join(repo, m.from);
    const dst = path.join(repo, m.to);
    await ensureDir(path.dirname(dst));
    // try git mv to preserve history
    const { code } = runSilent('git', ['mv', m.from, m.to]);
    if (code !== 0) {
      // fallback
      fs.renameSync(src, dst);
    }
  }

  // Update package.json names/scopes & default to private true
  const finalDirs = new Set(pkgs.map(p => targetDirFor(p.dir)));
  for (const dir of finalDirs) {
    const pj = path.join(repo, dir, 'package.json');
    if (!exists(pj)) continue;
    const pkg = await readJson(pj);
    const base = path.posix.basename(dir);
    const scoped = pkg.name && pkg.name.startsWith(SCOPE + '/') ? pkg.name : `${SCOPE}/${basenameNoScope(pkg.name ?? base)}`;
    pkg.name = scoped;
    if (pkg.private === undefined) pkg.private = true;
    pkg.type = pkg.type ?? 'module';
    await writeJson(pj, pkg);
  }
  report.push('');
  report.push('## Actions');
  report.push('- Scoped package.json names to @shinobi/* and set private:true by default.');

  // Update tsconfig.base.json paths
  const tsb = await readJson(path.join(repo, 'tsconfig.base.json')) || { compilerOptions: {} };
  tsb.compilerOptions.paths = tsb.compilerOptions.paths || {};
  for (const dir of finalDirs) {
    const base = path.posix.basename(dir);
    tsb.compilerOptions.paths[`${SCOPE}/${base}`] = [`${dir}/src`];
  }
  await writeJson(path.join(repo, 'tsconfig.base.json'), tsb);
  report.push('- Updated tsconfig.base.json paths to new package locations.');

  // Rewriting import specifiers -> use TypeScript AST via ts-morph (now installed)
  const { Project, SyntaxKind } = await import('ts-morph');
  const project = new Project({
    tsConfigFilePath: path.join(repo, 'tsconfig.base.json'),
    skipAddingFilesFromTsConfig: true,
  });

  // collect TS files
  function collectFiles(dir) {
    const files = [];
    function walk(d) {
      for (const ent of fs.readdirSync(d, { withFileTypes: true })) {
        if (ent.name === 'node_modules' || ent.name === '.git' || ent.name === 'dist' || ent.name === '.turbo' || ent.name === 'coverage') continue;
        const p = path.join(d, ent.name);
        if (ent.isDirectory()) walk(p);
        else if (/\.(ts|tsx|mts|cts)$/.test(ent.name)) files.push(p);
      }
    }
    walk(dir);
    return files;
  }
  const tsFiles = collectFiles(repo);
  project.addSourceFilesAtPaths(tsFiles);

  const bases = Array.from(movedNames);
  const isMovedBase = new Set(bases);

  function rewrite(spec) {
    const norm = spec.replace(/\\/g, '/');
    // any path containing /components/<name> or /libs/<name>
    for (const base of bases) {
      if (norm.includes(`/components/${base}`) || norm.includes(`/libs/${base}`) || norm.startsWith(`components/${base}`) || norm.startsWith(`libs/${base}`)) {
        return `${SCOPE}/${base}`;
      }
    }
    // bare import of a moved package name
    const bare = norm.split('/')[0];
    if (!norm.startsWith('.') && !norm.startsWith('@') && isMovedBase.has(bare)) {
      return `${SCOPE}/${bare}` + norm.slice(bare.length);
    }
    return spec;
  }

  let filesChanged = 0;
  for (const sf of project.getSourceFiles()) {
    let changed = false;
    // import ... from 'x'
    for (const imp of sf.getImportDeclarations()) {
      const spec = imp.getModuleSpecifierValue();
      const next = rewrite(spec);
      if (next !== spec) { imp.setModuleSpecifier(next); changed = true; }
    }
    // export ... from 'x'
    for (const exp of sf.getExportDeclarations()) {
      const spec = exp.getModuleSpecifierValue();
      if (!spec) continue;
      const next = rewrite(spec);
      if (next !== spec) { exp.setModuleSpecifier(next); changed = true; }
    }
    // require('x') & import('x')
    sf.forEachDescendant((node) => {
      if (node.getKind() === SyntaxKind.CallExpression) {
        const ce = node;
        const expr = ce.getExpression();
        const arg0 = ce.getArguments()[0];
        const isRequire = expr.getText() === 'require';
        const isImport = expr.getKind() === SyntaxKind.ImportKeyword;
        if ((isRequire || isImport) && arg0 && arg0.getKind() === SyntaxKind.StringLiteral) {
          const lit = arg0;
          const spec = lit.getLiteralValue();
          const next = rewrite(spec);
          if (next !== spec) { lit.setLiteralValue(next); changed = true; }
        }
      }
    });
    if (changed) { await sf.save(); filesChanged++; }
  }
  report.push(`- Rewrote import specifiers in ${filesChanged} file(s) to ${SCOPE}/*.`);

  // Write report
  await writeFile(path.join(repo, '.shinobi/MIGRATION_REPORT.md'), report.join('\n') + '\n');
  log('Wrote ./.shinobi/MIGRATION_REPORT.md');

  // Optional: create a blanket changeset for public packages (if any)
  const publicPackages = [];
  for (const dir of finalDirs) {
    const pj = await readJson(path.join(repo, dir, 'package.json'));
    if (pj && pj.private === false && pj.name) publicPackages.push(pj.name);
  }
  if (publicPackages.length) {
    const header = publicPackages.map(n => `'${n}': patch`).join('\n');
    const cs = `---
${header}
---
chore: repo migration to package-per-component layout and @shinobi scope
`;
    const csName = `.changeset/${Date.now()}-repo-migration.md`;
    await writeFile(path.join(repo, csName), cs);
    log(`Created changeset for public packages: ${csName}`);
  } else {
    log('No public packages detected; skipping auto changeset.');
  }
}

async function stepVerifyBuild() {
  log('Verifying build/test/lint/typecheck via Turbo…');
  // best-effort; don’t fail the whole run if tests aren’t present yet
  const res = runSilent('pnpm', ['dlx', 'turbo', 'run', 'lint', 'typecheck', 'build', 'test', '--', '--run']);
  process.stdout.write(res.out);
  if (res.code !== 0) warn('Verification failed; inspect output above (this is non-fatal for migration).');
}

(async function main() {
  log('Starting Shinobi one-shot…');
  assertCleanGit();
  await stepProjenBlueprint();
  await stepProjenSynthAndInstall();
  await stepMigrateLayoutAndPaths();
  await stepVerifyBuild();
  log('Done. Review ./.shinobi/MIGRATION_REPORT.md, run tests, and commit.');
  log('Suggested follow-up: pnpm changeset (if you changed public packages) and open a PR.');
})();
