#!/usr/bin/env node

const { Command } = require('commander');
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const program = new Command();

program
  .name('svc')
  .description('Shinobi Platform CLI')
  .version('1.0.0')
  .option('--verbose, -v', 'Enable verbose logging')
  .option('--ci', 'Enable CI mode (structured JSON output)');

// svc init command
program
  .command('init')
  .description('Scaffold a new service from a template')
  .option('--name <name>', 'Service name')
  .option('--owner <owner>', 'Service owner/team')
  .option('--framework <framework>', 'Compliance framework', 'commercial')
  .option('--pattern <pattern>', 'Initial pattern', 'empty')
  .action(async (options, cmd) => {
    const opts = cmd.parent.opts();

    // Create logger
    const { Logger } = require('../dist/utils/logger.js');
    const logger = Logger.getLogger('svc-init');
    logger.configure({ verbose: opts.verbose, ci: opts.ci });

    logger.info('üöÄ Initializing new service...');
    logger.debug('Options:', options);

    // Create basic service.yml
    const serviceYaml = `service: ${options.name || 'my-service'}
owner: ${options.owner || 'dev-team'}
complianceFramework: ${options.framework}
environment: development

components:
  - name: web-server
    type: ec2-instance
    config:
      instanceType: t3.micro
      ami:
        namePattern: 'al2023-ami-*-x86_64'
        owner: 'amazon'
      userData:
        script: |
          #!/bin/bash
          yum update -y
          yum install -y httpd
          systemctl start httpd
          echo "<h1>Hello from Shinobi Platform</h1>" > /var/www/html/index.html
      storage:
        rootVolumeSize: 20
        encrypted: true

  - name: app-storage
    type: s3-bucket
    config:
      bucketName: ${options.name || 'my-service'}-storage
      versioning: true
      encryption:
        enabled: true

governance:
  tags:
    Service: ${options.name || 'my-service'}
    Owner: ${options.owner || 'dev-team'}
    Environment: \${environment}
    Compliance: ${options.framework}
    ManagedBy: shinobi
`;

    fs.writeFileSync('service.yml', serviceYaml);
    logger.info('‚úÖ Created service.yml');
    logger.info('Next steps:');
    logger.info('  1. Review and customize service.yml');
    logger.info('  2. Run "svc validate" to check the manifest');
    logger.info('  3. Run "svc plan" to see what will be deployed');
  });

// svc validate command
program
  .command('validate')
  .description('Parse and validate the service.yml without connecting to AWS')
  .option('--file, -f <file>', 'Path to service.yml file', 'service.yml')
  .action(async (options, cmd) => {
    const opts = cmd.parent.opts();

    // Create logger
    const { Logger } = require('../dist/utils/logger.js');
    const logger = Logger.getLogger('svc-validate');
    logger.configure({ verbose: opts.verbose, ci: opts.ci });

    logger.info('üîç Validating service manifest...');

    if (!fs.existsSync(options.file)) {
      logger.error(`‚ùå File not found: ${options.file}`);
      process.exit(1);
    }

    try {
      const yaml = require('js-yaml');
      const content = fs.readFileSync(options.file, 'utf8');
      const manifest = yaml.load(content);

      if (!manifest.service) {
        throw new Error('Missing required field: service');
      }
      if (!manifest.owner) {
        throw new Error('Missing required field: owner');
      }
      if (!manifest.complianceFramework) {
        manifest.complianceFramework = 'commercial';
      }

      // Validate component types
      const supportedTypes = [
        'api-gateway-rest', 'api-gateway-http', 'ec2-instance', 's3-bucket',
        'lambda-api', 'rds-postgres', 'elasticache-redis', 'vpc',
        'dynamodb-table', 'sqs-queue', 'sns-topic', 'ecs-cluster',
        'application-load-balancer', 'certificate-manager', 'cognito-user-pool',
        'cloudfront-distribution', 'efs-filesystem', 'eventbridge-rule-cron',
        'eventbridge-rule-pattern', 'glue-job', 'iam-policy', 'iam-role',
        'kinesis-stream', 'lambda-worker', 'opensearch-domain',
        'route53-hosted-zone', 'sagemaker-notebook-instance', 'secrets-manager',
        'ssm-parameter', 'static-website', 'step-functions-statemachine', 'waf-web-acl'
      ];

      if (manifest.components && Array.isArray(manifest.components)) {
        for (const component of manifest.components) {
          if (!supportedTypes.includes(component.type)) {
            const availableTypes = supportedTypes.join(', ');
            const errorMessage = `Unsupported component type: ${component.type}. ` +
              `Available types: ${availableTypes}. ` +
              `This is not a valid manifest.`;
            logger.error(errorMessage);
            throw new Error(errorMessage);
          }
        }
      }

      logger.info('‚úÖ Service manifest is valid');
      logger.info(`   Service: ${manifest.service}`);
      logger.info(`   Owner: ${manifest.owner}`);
      logger.info(`   Components: ${manifest.components?.length || 0}`);
    } catch (error) {
      logger.error('‚ùå Validation failed:', error.message);
      process.exit(1);
    }
  });

// svc plan command
program
  .command('plan')
  .description('Perform full validation and output resolved configuration')
  .option('--file, -f <file>', 'Path to service.yml file')
  .option('--env <env>', 'Target environment', 'dev-us-east-1')
  .action(async (options, cmd) => {
    const opts = cmd.parent.opts();

    try {
      // Import the real PlanCommand and dependencies
      const { PlanCommand } = require('../dist/cli/plan.js');
      const { Logger } = require('../dist/utils/logger.js');
      const { FileDiscovery } = require('../dist/cli/utils/file-discovery.js');

      // Create a simplified ValidationOrchestrator for now
      const logger = Logger.getLogger('svc-cli');
      logger.configure({ verbose: opts.verbose, ci: opts.ci });

      const fileDiscovery = new FileDiscovery();

      // Create a mock ValidationOrchestrator that validates component types
      const mockValidationOrchestrator = {
        async plan(manifestPath, env) {
          logger.debug('Starting validation pipeline with component type validation');

          // Simple YAML parsing with proper path resolution
          const yaml = require('js-yaml');
          const fs = require('fs');
          const path = require('path');

          // Resolve the path relative to current working directory
          const resolvedPath = path.resolve(manifestPath);
          const content = fs.readFileSync(resolvedPath, 'utf8');
          const manifest = yaml.load(content);

          // Basic validation
          if (!manifest.service) {
            throw new Error('Missing required field: service');
          }
          if (!manifest.owner) {
            throw new Error('Missing required field: owner');
          }
          if (!manifest.complianceFramework) {
            manifest.complianceFramework = 'commercial';
          }

          // Validate component types
          const supportedTypes = [
            'api-gateway-rest', 'api-gateway-http', 'ec2-instance', 's3-bucket',
            'lambda-api', 'rds-postgres', 'elasticache-redis', 'vpc',
            'dynamodb-table', 'sqs-queue', 'sns-topic', 'ecs-cluster',
            'application-load-balancer', 'certificate-manager', 'cognito-user-pool',
            'cloudfront-distribution', 'efs-filesystem', 'eventbridge-rule-cron',
            'eventbridge-rule-pattern', 'glue-job', 'iam-policy', 'iam-role',
            'kinesis-stream', 'lambda-worker', 'opensearch-domain',
            'route53-hosted-zone', 'sagemaker-notebook-instance', 'secrets-manager',
            'ssm-parameter', 'static-website', 'step-functions-statemachine', 'waf-web-acl'
          ];

          const warnings = [];

          if (manifest.components && Array.isArray(manifest.components)) {
            for (const component of manifest.components) {
              if (!supportedTypes.includes(component.type)) {
                const availableTypes = supportedTypes.join(', ');
                const errorMessage = `Unsupported component type: ${component.type}. ` +
                  `Available types: ${availableTypes}. ` +
                  `This is not a valid manifest.`;
                logger.error(errorMessage);
                throw new Error(errorMessage);
              }

              // Basic compliance validation
              if (component.type === 's3-bucket' && !component.config?.encryption?.enabled) {
                warnings.push(`S3 bucket '${component.name}' should have encryption enabled for compliance`);
              }

              if (component.type === 'rds-postgres' && !component.config?.backupRetentionDays) {
                warnings.push(`RDS PostgreSQL '${component.name}' should specify backup retention for compliance`);
              }

              if (component.type === 'lambda-api' && !component.config?.environment) {
                warnings.push(`Lambda API '${component.name}' should have environment variables configured`);
              }

              // Apply platform tagging standard
              if (!component.tags) {
                component.tags = {};
              }

              // Core Service Tags (kebab-case as per standard)
              component.tags['service-name'] = manifest.service;
              component.tags['service-version'] = manifest.serviceVersion || '1.0.0';
              component.tags['component-name'] = component.name;
              component.tags['component-type'] = component.type;

              // Environment & Deployment Tags
              component.tags['environment'] = env;
              component.tags['region'] = process.env.AWS_DEFAULT_REGION || 'us-east-1';
              component.tags['deployed-by'] = 'platform-v1.0.0';
              component.tags['deployment-id'] = `deploy-${new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19)}`;

              // Governance & Compliance Tags
              component.tags['compliance-framework'] = manifest.complianceFramework;
              component.tags['data-classification'] = component.config?.dataClassification || 'internal';
              component.tags['backup-required'] = component.config?.backupRequired || 'false';
              component.tags['monitoring-level'] = manifest.complianceFramework === 'fedramp-high' ? 'comprehensive' :
                manifest.complianceFramework === 'fedramp-moderate' ? 'enhanced' : 'basic';

              // Cost Management Tags
              component.tags['cost-center'] = manifest.costCenter || 'engineering';
              component.tags['billing-project'] = manifest.billingProject || `proj-${manifest.service}`;
              component.tags['resource-owner'] = manifest.owner;
            }
          }

          logger.debug('Validation completed successfully');
          return {
            resolvedManifest: manifest,
            warnings: warnings
          };
        }
      };

      // Create plan command
      const planCommand = new PlanCommand({
        pipeline: mockValidationOrchestrator,
        fileDiscovery,
        logger
      });

      // Execute plan command
      const result = await planCommand.execute({
        file: options.file,
        env: options.env
      });

      if (!result.success) {
        if (opts.ci) {
          console.error(JSON.stringify({ level: 'error', message: result.error, timestamp: new Date().toISOString() }));
        } else {
          console.error(`‚ùå ${result.error}`);
        }
        process.exit(result.exitCode);
      }

      // Debug the result structure
      console.log('DEBUG: result:', JSON.stringify(result, null, 2));

      // Output results
      if (opts.ci) {
        const plan = {
          service: result.data.resolvedManifest.service,
          environment: options.env,
          activeFramework: result.data.resolvedManifest.complianceFramework,
          components: result.data.resolvedManifest.components || [],
          binds: result.data.resolvedManifest.binds || [],
          governance: result.data.resolvedManifest.governance || {},
          cdkDiff: result.data.cdkDiff,
          cloudFormationTemplate: result.data.cloudFormationTemplate,
          timestamp: new Date().toISOString()
        };
        console.log(JSON.stringify(plan, null, 2));
      } else {
        // Use the formatter to display the plan
        const { PlanOutputFormatter } = require('../dist/services/plan-output-formatter.js');
        const outputFormatter = new PlanOutputFormatter({
          logger: { info: console.log, error: console.error, success: console.log }
        });

        console.log('DEBUG: result.data:', JSON.stringify(result.data, null, 2));
        console.log('DEBUG: result.data.resolvedManifest:', JSON.stringify(result.data.resolvedManifest, null, 2));

        const formattedOutput = outputFormatter.formatPlanOutput({
          synthesisResult: {
            ...result.data.synthesisResult,
            resolvedManifest: result.data.resolvedManifest
          },
          cdkDiff: result.data.cdkDiff,
          environment: options.env,
          complianceFramework: result.data.resolvedManifest.complianceFramework || 'commercial'
        });

        console.log('\n' + formattedOutput.userFriendlySummary);
      }

      process.exit(0);
    } catch (error) {
      if (error.code === 'MANIFEST_NOT_FOUND') {
        console.error('‚ùå No service.yml found. Run "svc init" to create one.');
        process.exit(1);
      }
      console.error(`‚ùå Plan failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
      process.exit(2);
    }
  });

// svc inventory command
program
  .command('inventory')
  .description('Analyze CDK codebase and identify component opportunities')
  .argument('<directory>', 'Directory to analyze (e.g., ../my-service or ./)')
  .option('--output <path>', 'Custom output path for the report', 'INVENTORY_REPORT.md')
  .action(async (directory, options, cmd) => {
    const opts = cmd.parent.opts();

    // Create logger
    const { Logger } = require('../dist/utils/logger.js');
    const logger = Logger.getLogger('svc-inventory');
    logger.configure({ verbose: opts.verbose, ci: opts.ci });

    logger.info('üîç Analyzing codebase for component opportunities...');
    logger.info(`   Directory: ${directory}`);
    logger.info(`   Output: ${options.output}`);

    // Simple inventory analysis
    const inventoryReport = `# Platform Inventory Report

## Analysis Summary
- **Directory**: ${directory}
- **Analysis Date**: ${new Date().toISOString()}
- **Components Found**: 0 (placeholder)

## Recommendations
- Consider using Shinobi components for infrastructure
- Review existing CDK constructs for componentization opportunities
- Implement proper tagging and governance

*Generated by Shinobi Platform Inventory Tool v1.0*
`;

    fs.writeFileSync(options.output, inventoryReport);
    logger.info(`‚úÖ Inventory report generated: ${options.output}`);
  });

// svc synth command
program
  .command('synth')
  .description('Synthesize CDK app and output CloudFormation templates')
  .option('--file, -f <file>', 'Path to service.yml file', 'service.yml')
  .option('--env <env>', 'Target environment', 'dev')
  .option('--output <path>', 'Output directory for synthesized templates', 'cdk.out')
  .action(async (options, cmd) => {
    const opts = cmd.parent.opts();

    try {
      // Import the real platform components
      const { PlanCommand } = require('../dist/cli/plan.js');
      const { Logger } = require('../dist/utils/logger.js');
      const { FileDiscovery } = require('../dist/cli/utils/file-discovery.js');

      // Create dependencies
      const logger = Logger.getLogger('svc-synth');
      logger.configure({ verbose: opts.verbose, ci: opts.ci });

      const fileDiscovery = new FileDiscovery();

      // Create a mock ValidationOrchestrator that validates component types
      const mockValidationOrchestrator = {
        async plan(manifestPath, env) {
          logger.debug('Starting validation pipeline for synth');

          // Simple YAML parsing with proper path resolution
          const yaml = require('js-yaml');
          const fs = require('fs');
          const path = require('path');

          // Resolve the path relative to current working directory
          const resolvedPath = path.resolve(manifestPath);
          const content = fs.readFileSync(resolvedPath, 'utf8');
          const manifest = yaml.load(content);

          // Basic validation
          if (!manifest.service) {
            throw new Error('Missing required field: service');
          }
          if (!manifest.owner) {
            throw new Error('Missing required field: owner');
          }
          if (!manifest.complianceFramework) {
            manifest.complianceFramework = 'commercial';
          }

          // Validate component types
          const supportedTypes = [
            'api-gateway-rest', 'api-gateway-http', 'ec2-instance', 's3-bucket',
            'lambda-api', 'rds-postgres', 'elasticache-redis', 'vpc',
            'dynamodb-table', 'sqs-queue', 'sns-topic', 'ecs-cluster',
            'application-load-balancer', 'certificate-manager', 'cognito-user-pool',
            'cloudfront-distribution', 'efs-filesystem', 'eventbridge-rule-cron',
            'eventbridge-rule-pattern', 'glue-job', 'iam-policy', 'iam-role',
            'kinesis-stream', 'lambda-worker', 'opensearch-domain',
            'route53-hosted-zone', 'sagemaker-notebook-instance', 'secrets-manager',
            'ssm-parameter', 'static-website', 'step-functions-statemachine', 'waf-web-acl'
          ];

          if (manifest.components && Array.isArray(manifest.components)) {
            for (const component of manifest.components) {
              if (!supportedTypes.includes(component.type)) {
                const availableTypes = supportedTypes.join(', ');
                const errorMessage = `Unsupported component type: ${component.type}. ` +
                  `Available types: ${availableTypes}. ` +
                  `This is not a valid manifest.`;
                logger.error(errorMessage);
                throw new Error(errorMessage);
              }
            }
          }

          logger.debug('Validation completed successfully');
          return {
            resolvedManifest: manifest,
            warnings: []
          };
        }
      };

      // Create plan command
      const planCommand = new PlanCommand({
        pipeline: mockValidationOrchestrator,
        fileDiscovery,
        logger
      });

      // Execute plan command to get synthesis result
      const result = await planCommand.execute({
        file: options.file,
        env: options.env
      });

      if (!result.success) {
        if (opts.ci) {
          console.error(JSON.stringify({ level: 'error', message: result.error, timestamp: new Date().toISOString() }));
        } else {
          console.error(`‚ùå ${result.error}`);
        }
        process.exit(result.exitCode);
      }

      // Create output directory
      if (!fs.existsSync(options.output)) {
        fs.mkdirSync(options.output, { recursive: true });
      }

      // Write CloudFormation template to output directory
      const stackName = `${result.data.resolvedManifest.service}-stack`;
      const templatePath = path.join(options.output, `${stackName}.template.json`);

      fs.writeFileSync(templatePath, JSON.stringify(result.data.cloudFormationTemplate, null, 2));

      if (opts.ci) {
        console.log(JSON.stringify({
          level: 'info',
          message: 'Synthesis completed successfully',
          stackName: stackName,
          templatePath: templatePath,
          resources: Object.keys(result.data.cloudFormationTemplate.Resources || {}).length,
          timestamp: new Date().toISOString()
        }));
      } else {
        logger.info('‚úÖ Synthesis completed successfully');
        logger.info(`   Stack: ${stackName}`);
        logger.info(`   Template: ${templatePath}`);
        logger.info(`   Resources: ${Object.keys(result.data.cloudFormationTemplate.Resources || {}).length}`);
      }

      process.exit(0);
    } catch (error) {
      if (error.code === 'MANIFEST_NOT_FOUND') {
        console.error('‚ùå No service.yml found. Run "svc init" to create one.');
        process.exit(1);
      }
      console.error(`‚ùå Synthesis failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
      process.exit(2);
    }
  });

// svc diff command
program
  .command('diff')
  .description('Compare deployed stack with current state')
  .option('--file, -f <file>', 'Path to service.yml file', 'service.yml')
  .option('--env <env>', 'Target environment', 'dev')
  .action(async (options, cmd) => {
    const opts = cmd.parent.opts();

    try {
      // Import the real platform components
      const { PlanCommand } = require('../dist/cli/plan.js');
      const { Logger } = require('../dist/utils/logger.js');
      const { FileDiscovery } = require('../dist/cli/utils/file-discovery.js');

      // Create dependencies
      const logger = Logger.getLogger('svc-diff');
      logger.configure({ verbose: opts.verbose, ci: opts.ci });

      const fileDiscovery = new FileDiscovery();

      // Create a mock ValidationOrchestrator that validates component types
      const mockValidationOrchestrator = {
        async plan(manifestPath, env) {
          logger.debug('Starting validation pipeline for diff');

          // Simple YAML parsing with proper path resolution
          const yaml = require('js-yaml');
          const fs = require('fs');
          const path = require('path');

          // Resolve the path relative to current working directory
          const resolvedPath = path.resolve(manifestPath);
          const content = fs.readFileSync(resolvedPath, 'utf8');
          const manifest = yaml.load(content);

          // Basic validation
          if (!manifest.service) {
            throw new Error('Missing required field: service');
          }
          if (!manifest.owner) {
            throw new Error('Missing required field: owner');
          }
          if (!manifest.complianceFramework) {
            manifest.complianceFramework = 'commercial';
          }

          // Validate component types
          const supportedTypes = [
            'api-gateway-rest', 'api-gateway-http', 'ec2-instance', 's3-bucket',
            'lambda-api', 'rds-postgres', 'elasticache-redis', 'vpc',
            'dynamodb-table', 'sqs-queue', 'sns-topic', 'ecs-cluster',
            'application-load-balancer', 'certificate-manager', 'cognito-user-pool',
            'cloudfront-distribution', 'efs-filesystem', 'eventbridge-rule-cron',
            'eventbridge-rule-pattern', 'glue-job', 'iam-policy', 'iam-role',
            'kinesis-stream', 'lambda-worker', 'opensearch-domain',
            'route53-hosted-zone', 'sagemaker-notebook-instance', 'secrets-manager',
            'ssm-parameter', 'static-website', 'step-functions-statemachine', 'waf-web-acl'
          ];

          if (manifest.components && Array.isArray(manifest.components)) {
            for (const component of manifest.components) {
              if (!supportedTypes.includes(component.type)) {
                const availableTypes = supportedTypes.join(', ');
                const errorMessage = `Unsupported component type: ${component.type}. ` +
                  `Available types: ${availableTypes}. ` +
                  `This is not a valid manifest.`;
                logger.error(errorMessage);
                throw new Error(errorMessage);
              }
            }
          }

          logger.debug('Validation completed successfully');
          return {
            resolvedManifest: manifest,
            warnings: []
          };
        }
      };

      // Create plan command
      const planCommand = new PlanCommand({
        pipeline: mockValidationOrchestrator,
        fileDiscovery,
        logger
      });

      // Execute plan command to get diff result
      const result = await planCommand.execute({
        file: options.file,
        env: options.env
      });

      if (!result.success) {
        if (opts.ci) {
          console.error(JSON.stringify({ level: 'error', message: result.error, timestamp: new Date().toISOString() }));
        } else {
          console.error(`‚ùå ${result.error}`);
        }
        process.exit(result.exitCode);
      }

      // Display diff results
      const cdkDiff = result.data.cdkDiff;

      if (opts.ci) {
        console.log(JSON.stringify({
          level: 'info',
          message: 'Diff analysis completed',
          stackName: cdkDiff.stackName,
          changes: cdkDiff.changes,
          hasChanges: cdkDiff.hasChanges,
          resources: cdkDiff.resources,
          timestamp: new Date().toISOString()
        }));
      } else {
        logger.info('üìä Diff analysis completed');
        logger.info(`   Stack: ${cdkDiff.stackName}`);
        logger.info(`   Changes: ${cdkDiff.changes.added} added, ${cdkDiff.changes.modified} modified, ${cdkDiff.changes.removed} removed`);

        if (cdkDiff.hasChanges) {
          logger.info('\n--- Infrastructure Changes ---');

          if (Object.keys(cdkDiff.resources.added).length > 0) {
            logger.info('\nResources to be created:');
            Object.keys(cdkDiff.resources.added).forEach(resourceName => {
              const resource = cdkDiff.resources.added[resourceName];
              logger.info(`  + ${resourceName} (${resource.type})`);
            });
          }

          if (Object.keys(cdkDiff.resources.modified).length > 0) {
            logger.info('\nResources to be modified:');
            Object.keys(cdkDiff.resources.modified).forEach(resourceName => {
              const resource = cdkDiff.resources.modified[resourceName];
              logger.info(`  ~ ${resourceName} (${resource.type})`);
            });
          }

          if (Object.keys(cdkDiff.resources.removed).length > 0) {
            logger.info('\nResources to be removed:');
            Object.keys(cdkDiff.resources.removed).forEach(resourceName => {
              const resource = cdkDiff.resources.removed[resourceName];
              logger.info(`  - ${resourceName} (${resource.type})`);
            });
          }
        } else {
          logger.info('   No infrastructure changes detected');
        }
      }

      process.exit(0);
    } catch (error) {
      if (error.code === 'MANIFEST_NOT_FOUND') {
        console.error('‚ùå No service.yml found. Run "svc init" to create one.');
        process.exit(1);
      }
      console.error(`‚ùå Diff failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
      process.exit(2);
    }
  });

// svc deploy command
program
  .command('deploy')
  .description('Deploy the service to AWS using CDK')
  .option('--file, -f <file>', 'Path to service.yml file', 'service.yml')
  .option('--env <env>', 'Target environment', 'dev')
  .option('--force', 'Force deployment even if no changes detected')
  .option('--dry-run', 'Show what would be deployed without deploying')
  .action(async (options, cmd) => {
    const opts = cmd.parent.opts();

    try {
      // Import the real platform components
      const { PlanCommand } = require('../dist/cli/plan.js');
      const { Logger } = require('../dist/utils/logger.js');
      const { FileDiscovery } = require('../dist/cli/utils/file-discovery.js');

      // Create dependencies
      const logger = Logger.getLogger('svc-deploy');
      logger.configure({ verbose: opts.verbose, ci: opts.ci });

      const fileDiscovery = new FileDiscovery();

      // Create a mock ValidationOrchestrator that validates component types
      const mockValidationOrchestrator = {
        async plan(manifestPath, env) {
          logger.debug('Starting validation pipeline for deploy');

          // Simple YAML parsing with proper path resolution
          const yaml = require('js-yaml');
          const fs = require('fs');
          const path = require('path');

          // Resolve the path relative to current working directory
          const resolvedPath = path.resolve(manifestPath);
          const content = fs.readFileSync(resolvedPath, 'utf8');
          const manifest = yaml.load(content);

          // Basic validation
          if (!manifest.service) {
            throw new Error('Missing required field: service');
          }
          if (!manifest.owner) {
            throw new Error('Missing required field: owner');
          }
          if (!manifest.complianceFramework) {
            manifest.complianceFramework = 'commercial';
          }

          // Validate component types
          const supportedTypes = [
            'api-gateway-rest', 'api-gateway-http', 'ec2-instance', 's3-bucket',
            'lambda-api', 'rds-postgres', 'elasticache-redis', 'vpc',
            'dynamodb-table', 'sqs-queue', 'sns-topic', 'ecs-cluster',
            'application-load-balancer', 'certificate-manager', 'cognito-user-pool',
            'cloudfront-distribution', 'efs-filesystem', 'eventbridge-rule-cron',
            'eventbridge-rule-pattern', 'glue-job', 'iam-policy', 'iam-role',
            'kinesis-stream', 'lambda-worker', 'opensearch-domain',
            'route53-hosted-zone', 'sagemaker-notebook-instance', 'secrets-manager',
            'ssm-parameter', 'static-website', 'step-functions-statemachine', 'waf-web-acl'
          ];

          if (manifest.components && Array.isArray(manifest.components)) {
            for (const component of manifest.components) {
              if (!supportedTypes.includes(component.type)) {
                const availableTypes = supportedTypes.join(', ');
                const errorMessage = `Unsupported component type: ${component.type}. ` +
                  `Available types: ${availableTypes}. ` +
                  `This is not a valid manifest.`;
                logger.error(errorMessage);
                throw new Error(errorMessage);
              }
            }
          }

          logger.debug('Validation completed successfully');
          return {
            resolvedManifest: manifest,
            warnings: []
          };
        }
      };

      // Create plan command
      const planCommand = new PlanCommand({
        pipeline: mockValidationOrchestrator,
        fileDiscovery,
        logger
      });

      // Execute plan command to get synthesis result
      const result = await planCommand.execute({
        file: options.file,
        env: options.env
      });

      if (!result.success) {
        if (opts.ci) {
          console.error(JSON.stringify({ level: 'error', message: result.error, timestamp: new Date().toISOString() }));
        } else {
          console.error(`‚ùå ${result.error}`);
        }
        process.exit(result.exitCode);
      }

      const cdkDiff = result.data.cdkDiff;
      const stackName = `${result.data.resolvedManifest.service}-stack`;

      if (options.dryRun) {
        if (opts.ci) {
          console.log(JSON.stringify({
            level: 'info',
            message: 'Dry run completed',
            stackName: stackName,
            changes: cdkDiff.changes,
            hasChanges: cdkDiff.hasChanges,
            resources: cdkDiff.resources,
            timestamp: new Date().toISOString()
          }));
        } else {
          logger.info('üîç DRY RUN MODE - No actual deployment');
          logger.info(`   Stack: ${stackName}`);
          logger.info(`   Changes: ${cdkDiff.changes.added} added, ${cdkDiff.changes.modified} modified, ${cdkDiff.changes.removed} removed`);

          if (cdkDiff.hasChanges) {
            logger.info('\n--- Infrastructure Changes ---');

            if (Object.keys(cdkDiff.resources.added).length > 0) {
              logger.info('\nResources to be created:');
              Object.keys(cdkDiff.resources.added).forEach(resourceName => {
                const resource = cdkDiff.resources.added[resourceName];
                logger.info(`  + ${resourceName} (${resource.type})`);
              });
            }

            if (Object.keys(cdkDiff.resources.modified).length > 0) {
              logger.info('\nResources to be modified:');
              Object.keys(cdkDiff.resources.modified).forEach(resourceName => {
                const resource = cdkDiff.resources.modified[resourceName];
                logger.info(`  ~ ${resourceName} (${resource.type})`);
              });
            }

            if (Object.keys(cdkDiff.resources.removed).length > 0) {
              logger.info('\nResources to be removed:');
              Object.keys(cdkDiff.resources.removed).forEach(resourceName => {
                const resource = cdkDiff.resources.removed[resourceName];
                logger.info(`  - ${resourceName} (${resource.type})`);
              });
            }
          } else {
            logger.info('   No infrastructure changes detected');
          }
        }
        process.exit(0);
      }

      // Check if there are changes to deploy
      if (!cdkDiff.hasChanges && !options.force) {
        if (opts.ci) {
          console.log(JSON.stringify({
            level: 'info',
            message: 'No changes to deploy',
            stackName: stackName,
            timestamp: new Date().toISOString()
          }));
        } else {
          logger.info('‚ÑπÔ∏è  No changes to deploy');
          logger.info(`   Stack: ${stackName}`);
          logger.info('   Use --force to deploy anyway');
        }
        process.exit(0);
      }

      // For now, we'll use CDK CLI for actual deployment
      // TODO: Implement real CDK deployment using AWS SDK
      let cdkCommand = `npx cdk deploy`;
      if (options.force) {
        cdkCommand += ' --force';
      }
      cdkCommand += ' --require-approval never'; // Auto-approve for now

      if (opts.ci) {
        console.log(JSON.stringify({
          level: 'info',
          message: 'Starting deployment',
          stackName: stackName,
          command: cdkCommand,
          changes: cdkDiff.changes,
          timestamp: new Date().toISOString()
        }));
      } else {
        logger.info('üöÄ Starting deployment');
        logger.info(`   Stack: ${stackName}`);
        logger.info(`   Command: ${cdkCommand}`);
        logger.info(`   Changes: ${cdkDiff.changes.added} added, ${cdkDiff.changes.modified} modified, ${cdkDiff.changes.removed} removed`);
      }

      execSync(cdkCommand, {
        stdio: 'inherit',
        env: { ...process.env }
      });

      if (opts.ci) {
        console.log(JSON.stringify({
          level: 'info',
          message: 'Deployment completed successfully',
          stackName: stackName,
          timestamp: new Date().toISOString()
        }));
      } else {
        logger.info('‚úÖ Deployment completed successfully');
        logger.info(`   Stack: ${stackName}`);
      }

      process.exit(0);
    } catch (error) {
      if (error.code === 'MANIFEST_NOT_FOUND') {
        console.error('‚ùå No service.yml found. Run "svc init" to create one.');
        process.exit(1);
      }
      console.error(`‚ùå Deployment failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
      process.exit(2);
    }
  });

// svc up command (main deployment command using ResolverEngine)
program
  .command('up')
  .description('Deploy the service using the real ResolverEngine')
  .option('--file, -f <file>', 'Path to service.yml file', 'service.yml')
  .option('--env <env>', 'Target environment', 'dev')
  .option('--force', 'Force deployment even if no changes detected')
  .option('--dry-run', 'Show what would be deployed without deploying')
  .action(async (options, cmd) => {
    const opts = cmd.parent.opts();

    try {
      // Import the real platform components
      const { PlanCommand } = require('../dist/cli/plan.js');
      const { Logger } = require('../dist/utils/logger.js');
      const { FileDiscovery } = require('../dist/cli/utils/file-discovery.js');

      // Create dependencies
      const logger = Logger.getLogger('svc-up');
      logger.configure({ verbose: opts.verbose, ci: opts.ci });

      const fileDiscovery = new FileDiscovery();

      // Create a mock ValidationOrchestrator that validates component types
      const mockValidationOrchestrator = {
        async plan(manifestPath, env) {
          logger.debug('Starting validation pipeline for up');

          // Simple YAML parsing with proper path resolution
          const yaml = require('js-yaml');
          const fs = require('fs');
          const path = require('path');

          // Resolve the path relative to current working directory
          const resolvedPath = path.resolve(manifestPath);
          const content = fs.readFileSync(resolvedPath, 'utf8');
          const manifest = yaml.load(content);

          // Basic validation
          if (!manifest.service) {
            throw new Error('Missing required field: service');
          }
          if (!manifest.owner) {
            throw new Error('Missing required field: owner');
          }
          if (!manifest.complianceFramework) {
            manifest.complianceFramework = 'commercial';
          }

          // Validate component types
          const supportedTypes = [
            'api-gateway-rest', 'api-gateway-http', 'ec2-instance', 's3-bucket',
            'lambda-api', 'rds-postgres', 'elasticache-redis', 'vpc',
            'dynamodb-table', 'sqs-queue', 'sns-topic', 'ecs-cluster',
            'application-load-balancer', 'certificate-manager', 'cognito-user-pool',
            'cloudfront-distribution', 'efs-filesystem', 'eventbridge-rule-cron',
            'eventbridge-rule-pattern', 'glue-job', 'iam-policy', 'iam-role',
            'kinesis-stream', 'lambda-worker', 'opensearch-domain',
            'route53-hosted-zone', 'sagemaker-notebook-instance', 'secrets-manager',
            'ssm-parameter', 'static-website', 'step-functions-statemachine', 'waf-web-acl'
          ];

          if (manifest.components && Array.isArray(manifest.components)) {
            for (const component of manifest.components) {
              if (!supportedTypes.includes(component.type)) {
                const availableTypes = supportedTypes.join(', ');
                const errorMessage = `Unsupported component type: ${component.type}. ` +
                  `Available types: ${availableTypes}. ` +
                  `This is not a valid manifest.`;
                logger.error(errorMessage);
                throw new Error(errorMessage);
              }
            }
          }

          logger.debug('Validation completed successfully');
          return {
            resolvedManifest: manifest,
            warnings: []
          };
        }
      };

      // Create plan command for validation
      const planCommand = new PlanCommand({
        pipeline: mockValidationOrchestrator,
        fileDiscovery,
        logger
      });

      // Execute plan command to get synthesis result
      const result = await planCommand.execute({
        file: options.file,
        env: options.env
      });

      if (!result.success) {
        if (opts.ci) {
          console.error(JSON.stringify({ level: 'error', message: result.error, timestamp: new Date().toISOString() }));
        } else {
          console.error(`‚ùå ${result.error}`);
        }
        process.exit(result.exitCode);
      }

      const cdkDiff = result.data.cdkDiff;
      const stackName = `${result.data.resolvedManifest.service}-stack`;

      if (options.dryRun) {
        if (opts.ci) {
          console.log(JSON.stringify({
            level: 'info',
            message: 'Dry run completed',
            stackName: stackName,
            changes: cdkDiff.changes,
            hasChanges: cdkDiff.hasChanges,
            resources: cdkDiff.resources,
            timestamp: new Date().toISOString()
          }));
        } else {
          logger.info('üîç DRY RUN MODE - No actual deployment');
          logger.info(`   Stack: ${stackName}`);
          logger.info(`   Changes: ${cdkDiff.changes.added} added, ${cdkDiff.changes.modified} modified, ${cdkDiff.changes.removed} removed`);

          if (cdkDiff.hasChanges) {
            logger.info('\n--- Infrastructure Changes ---');

            if (Object.keys(cdkDiff.resources.added).length > 0) {
              logger.info('\nResources to be created:');
              Object.keys(cdkDiff.resources.added).forEach(resourceName => {
                const resource = cdkDiff.resources.added[resourceName];
                logger.info(`  + ${resourceName} (${resource.type})`);
              });
            }

            if (Object.keys(cdkDiff.resources.modified).length > 0) {
              logger.info('\nResources to be modified:');
              Object.keys(cdkDiff.resources.modified).forEach(resourceName => {
                const resource = cdkDiff.resources.modified[resourceName];
                logger.info(`  ~ ${resourceName} (${resource.type})`);
              });
            }

            if (Object.keys(cdkDiff.resources.removed).length > 0) {
              logger.info('\nResources to be removed:');
              Object.keys(cdkDiff.resources.removed).forEach(resourceName => {
                const resource = cdkDiff.resources.removed[resourceName];
                logger.info(`  - ${resourceName} (${resource.type})`);
              });
            }
          } else {
            logger.info('   No infrastructure changes detected');
          }
        }
        process.exit(0);
      }

      // Check if there are changes to deploy
      if (!cdkDiff.hasChanges && !options.force) {
        if (opts.ci) {
          console.log(JSON.stringify({
            level: 'info',
            message: 'No changes to deploy',
            stackName: stackName,
            timestamp: new Date().toISOString()
          }));
        } else {
          logger.info('‚ÑπÔ∏è  No changes to deploy');
          logger.info(`   Stack: ${stackName}`);
          logger.info('   Use --force to deploy anyway');
        }
        process.exit(0);
      }

      // Use real CDK synthesis (already done by PlanCommand)
      logger.info('üîß Using real CDK synthesis...');

      const synthesisResult = result.data.synthesisResult;

      logger.info(`‚úÖ CDK synthesis completed`);
      logger.info(`   Stack: ${synthesisResult.synthesizedStack.stackName}`);
      logger.info(`   Resources: ${Object.keys(synthesisResult.synthesizedStack.template.Resources || {}).length}`);

      // For now, we'll use CDK CLI for actual deployment
      // TODO: Implement real CDK deployment using AWS SDK
      let cdkCommand = `npx cdk deploy`;
      if (options.force) {
        cdkCommand += ' --force';
      }
      cdkCommand += ' --require-approval never'; // Auto-approve for now

      if (opts.ci) {
        console.log(JSON.stringify({
          level: 'info',
          message: 'Starting deployment with ResolverEngine',
          stackName: stackName,
          command: cdkCommand,
          changes: cdkDiff.changes,
          resources: Object.keys(synthesisResult.synthesizedStack.template.Resources || {}).length,
          timestamp: new Date().toISOString()
        }));
      } else {
        logger.info('üöÄ Starting deployment with ResolverEngine');
        logger.info(`   Stack: ${stackName}`);
        logger.info(`   Command: ${cdkCommand}`);
        logger.info(`   Changes: ${cdkDiff.changes.added} added, ${cdkDiff.changes.modified} modified, ${cdkDiff.changes.removed} removed`);
        logger.info(`   Resources: ${Object.keys(synthesisResult.synthesizedStack.template.Resources || {}).length}`);
      }

      execSync(cdkCommand, {
        stdio: 'inherit',
        env: { ...process.env }
      });

      if (opts.ci) {
        console.log(JSON.stringify({
          level: 'info',
          message: 'Deployment completed successfully with real CDK synthesis',
          stackName: stackName,
          resources: Object.keys(synthesisResult.synthesizedStack.template.Resources || {}).length,
          timestamp: new Date().toISOString()
        }));
      } else {
        logger.info('‚úÖ Deployment completed successfully with real CDK synthesis');
        logger.info(`   Stack: ${stackName}`);
        logger.info(`   Resources: ${Object.keys(synthesisResult.synthesizedStack.template.Resources || {}).length}`);
      }

      process.exit(0);
    } catch (error) {
      if (error.code === 'MANIFEST_NOT_FOUND') {
        console.error('‚ùå No service.yml found. Run "svc init" to create one.');
        process.exit(1);
      }
      console.error(`‚ùå Deployment failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
      process.exit(2);
    }
  });

// svc destroy command
program
  .command('destroy')
  .description('Destroy the deployed service')
  .option('--file, -f <file>', 'Path to service.yml file', 'service.yml')
  .option('--env <env>', 'Target environment', 'dev')
  .option('--force', 'Force destruction without confirmation')
  .action(async (options, cmd) => {
    const opts = cmd.parent.opts();

    // Create logger
    const { Logger } = require('../dist/utils/logger.js');
    const logger = Logger.getLogger('svc-destroy');
    logger.configure({ verbose: opts.verbose, ci: opts.ci });

    logger.info('üí• Destroying service...');

    if (!fs.existsSync(options.file)) {
      logger.error(`‚ùå File not found: ${options.file}`);
      process.exit(1);
    }

    try {
      // Load environment variables
      if (fs.existsSync('.env')) {
        const envContent = fs.readFileSync('.env', 'utf8');
        const envLines = envContent.split('\n');
        for (const line of envLines) {
          if (line.trim() && !line.startsWith('#')) {
            const [key, value] = line.split('=');
            if (key && value) {
              process.env[key.trim()] = value.trim().replace(/"/g, '');
            }
          }
        }
      }

      logger.info(`   Environment: ${options.env}`);

      // Run CDK destroy
      let cdkCommand = `npx cdk destroy`;
      if (options.force) {
        cdkCommand += ' --force';
      }

      logger.info(`   Running: ${cdkCommand}`);

      execSync(cdkCommand, {
        stdio: 'inherit',
        env: { ...process.env }
      });

      logger.info('‚úÖ Destruction completed successfully');
    } catch (error) {
      logger.error('‚ùå Destruction failed:', error.message);
      process.exit(1);
    }
  });

program.parse();
